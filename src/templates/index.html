<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Predicción de Criptomonedas - Dashboard</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #f8f9fa;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem 0;
            margin-bottom: 2rem;
        }
        
        .chart-container {
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .metric-card {
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            text-align: center;
            margin-bottom: 1rem;
        }
        
        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
        }
        
        .metric-label {
            color: #6c757d;
            font-size: 0.9rem;
        }
        
        .loading {
            text-align: center;
            padding: 3rem;
        }
        
        .controls {
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .model-selector {
            margin-bottom: 1rem;
        }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .status-active {
            background-color: #28a745;
        }
        
        .status-inactive {
            background-color: #dc3545;
        }
        
        .step-controls {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        
        /* Estilos para la tarjeta de pronóstico */
        .forecast-container {
            display: flex;
            gap: 30px;
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: 1px solid #e0e0e0;
            align-items: center;
        }
        
        .forecast-chart {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .forecast-chart canvas {
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #fafafa;
        }
        
        .forecast-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding-left: 20px;
            border-left: 2px solid #e9ecef;
        }
        
        .forecast-header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .forecast-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        
        .forecast-model {
            font-size: 0.85rem;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .forecast-probabilities {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .prob-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.3s ease;
        }
        
        .prob-item.main {
            transform: scale(1.1);
        }
        
        .prob-item.secondary {
            opacity: 0.6;
            transform: scale(0.9);
        }
        
        .prob-arrow {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 8px;
            transition: all 0.3s ease;
        }
        
        .prob-item.main .prob-arrow {
            font-size: 3.5rem;
        }
        
        .prob-item.secondary .prob-arrow {
            font-size: 2rem;
        }
        
        .prob-arrow.up {
            color: #27ae60;
        }
        
        .prob-arrow.down {
            color: #e74c3c;
        }
        
        .prob-text {
            font-size: 1.1rem;
            font-weight: 600;
            color: #495057;
            transition: all 0.3s ease;
        }
        
        .prob-item.main .prob-text {
            font-size: 1.3rem;
            font-weight: 700;
        }
        
        .prob-item.secondary .prob-text {
            font-size: 1rem;
        }
        
        .forecast-date {
            font-size: 1rem;
            font-weight: 500;
            color: #495057;
            text-align: center;
            margin-bottom: 15px;
            padding: 8px 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .forecast-metrics {
            font-size: 0.8rem;
            color: #6c757d;
            text-align: center;
            padding-top: 15px;
            border-top: 1px solid #dee2e6;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .forecast-container {
                flex-direction: column;
                gap: 20px;
            }
            
            .forecast-info {
                padding-left: 0;
                border-left: none;
                border-top: 2px solid #e9ecef;
                padding-top: 20px;
            }
            
            .forecast-chart canvas {
                width: 100%;
                max-width: 300px;
            }
        }
        
        /* Animaciones */
        .forecast-container {
            animation: fadeInUp 0.6s ease-out;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .prob-arrow {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }
        
        /* Estilos obsoletos de la tarjeta anterior */
        .forecast-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            border: 2px solid #e0e0e0;
            max-width: 500px;
            margin: 0 auto;
        }
        
        .forecast-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 25px;
            padding: 0 20px;
        }
        
        .forecast-arrow {
            font-size: 4rem;
            padding: 20px;
            border-radius: 50%;
            margin-right: 20px;
        }
        
        .forecast-arrow.up {
            background: linear-gradient(135deg, #52c41a, #389e0d);
            color: white;
            box-shadow: 0 4px 15px rgba(82, 196, 26, 0.4);
        }
        
        .forecast-arrow.down {
            background: linear-gradient(135deg, #ff4d4f, #cf1322);
            color: white;
            box-shadow: 0 4px 15px rgba(255, 77, 79, 0.4);
        }
        
        .forecast-main {
            flex: 1;
            text-align: left;
        }
        
        .forecast-secondary {
            flex: 1;
            text-align: right;
        }
        
        .forecast-direction {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .forecast-percentage {
            font-size: 2rem;
            font-weight: 700;
        }
        
        .forecast-direction.up,
        .forecast-percentage.up {
            color: #52c41a;
        }
        
        .forecast-direction.down,
        .forecast-percentage.down {
            color: #ff4d4f;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="container">
            <div class="row">
                <div class="col-md-8">
                    <h1><i class="fas fa-chart-line me-3"></i>Predicción de Criptomonedas</h1>
                    <p class="lead">Dashboard de análisis y predicción de precios usando Machine Learning</p>
                </div>
                <div class="col-md-4 text-end">
                    <div class="mt-3">
                        <span class="status-indicator status-active"></span>
                        <span>Modelos Activos</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="container-fluid">

        <!-- Paso 1: Regresión Directa del Precio -->
        <div class="row">
            <div class="col-12 mb-4">
                <div class="chart-container">
                    <div class="row align-items-center mb-3">
                        <div class="col-md-8">
                            <h3><i class="fas fa-chart-line me-2"></i>Paso 1: Regresión Directa del Precio</h3>
                            <p class="text-muted">Predicción del valor numérico del precio de cierre</p>
                        </div>
                        <div class="col-md-4">
                            <div class="row">
                                <div class="col-md-6">
                                    <label for="step1ModelSelect" class="form-label">Modelo:</label>
                                    <select id="step1ModelSelect" class="form-select">
                                        <option value="random_forest">Random Forest</option>
                                        <option value="linear_regression">Regresión Lineal</option>
                                    </select>
                                </div>
                                <div class="col-md-6">
                                    <label for="step1DaysSelect" class="form-label">Días:</label>
                                    <select id="step1DaysSelect" class="form-select">
                                        <option value="1">1 día</option>
                                        <option value="7" selected>7 días</option>
                                        <option value="15">15 días</option>
                                        <option value="30">30 días</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="step1Chart"></div>
                </div>
            </div>
        </div>

        <!-- Paso 2: Clasificación Binaria -->
        <div class="row">
            <div class="col-12 mb-4">
                <div class="chart-container">
                    <div class="row align-items-center mb-3">
                        <div class="col-md-8">
                            <h3><i class="fas fa-chart-bar me-2"></i>Paso 2: Clasificación Binaria (Sube/Baja)</h3>
                            <p class="text-muted">Predicción de la dirección del movimiento del precio</p>
                        </div>
                        <div class="col-md-4">
                            <div class="row">
                                <div class="col-md-6">
                                    <label for="step2ModelSelect" class="form-label">Modelo:</label>
                                    <select id="step2ModelSelect" class="form-select">
                                        <option value="random_forest">Random Forest</option>
                                        <option value="logistic_regression">Regresión Logística</option>
                                    </select>
                                </div>
                                <div class="col-md-6">
                                    <label for="step2DaysSelect" class="form-label">Días:</label>
                                    <select id="step2DaysSelect" class="form-select">
                                        <option value="1">1 día</option>
                                        <option value="7" selected>7 días</option>
                                        <option value="15">15 días</option>
                                        <option value="30">30 días</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="step2Chart"></div>
                </div>
            </div>
        </div>

        <!-- Paso 3: Probabilidad de Incremento -->
        <div class="row">
            <div class="col-12 mb-4">
                <div class="chart-container">
                    <div class="row align-items-center mb-3">
                        <div class="col-md-8">
                            <h3><i class="fas fa-chart-area me-2"></i>Paso 3: Probabilidad de Incremento Significativo</h3>
                            <p class="text-muted">Estimación de probabilidad de incremento</p>
                        </div>
                        <div class="col-md-4">
                            <div class="row">
                                <div class="col-md-6">
                                    <label for="step3ModelSelect" class="form-label">Modelo:</label>
                                    <select id="step3ModelSelect" class="form-select">
                                        <option value="random_forest">Random Forest</option>
                                        <option value="logistic_regression">Regresión Logística</option>
                                    </select>
                                </div>
                                <div class="col-md-6">
                                    <label for="step3DaysSelect" class="form-label">Días:</label>
                                    <select id="step3DaysSelect" class="form-select">
                                        <option value="1">1 día</option>
                                        <option value="7" >7 días</option>
                                        <option value="15" selected>15 días</option>
                                        <option value="30">30 días</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="step3Chart"></div>
                </div>
            </div>
        </div>

        <!-- Gráficos Adicionales -->
        <div class="row">
            <div class="col-md-6">
                <div class="chart-container">
                    <h4><i class="fas fa-chart-bar me-2"></i>Volumen de Transacciones</h4>
                    <div id="volumeChart"></div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="chart-container">
                    <h4><i class="fas fa-chart-line me-2"></i>Indicadores Técnicos</h4>
                    <div id="indicatorsChart"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        class CryptoDashboard {
            constructor() {
                this.data = null;
                this.step1Model = 'random_forest';
                this.step1Days = 7;
                this.step2Model = 'random_forest';
                this.step2Days = 7;
                this.step3Model = 'random_forest';
                this.step3Days = 15;
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.loadData();
            }

            setupEventListeners() {
                // Event listeners para Paso 1
                document.getElementById('step1ModelSelect').addEventListener('change', (e) => {
                    this.step1Model = e.target.value;
                    this.updateStep1Chart();
                });

                document.getElementById('step1DaysSelect').addEventListener('change', (e) => {
                    this.step1Days = parseInt(e.target.value);
                    this.updateStep1Chart();
                });

                // Event listeners para Paso 2
                document.getElementById('step2ModelSelect').addEventListener('change', (e) => {
                    this.step2Model = e.target.value;
                    this.updateStep2Chart();
                });

                document.getElementById('step2DaysSelect').addEventListener('change', (e) => {
                    this.step2Days = parseInt(e.target.value);
                    this.updateStep2Chart();
                });

                // Event listeners para Paso 3
                document.getElementById('step3ModelSelect').addEventListener('change', (e) => {
                    this.step3Model = e.target.value;
                    this.updateStep3Chart();
                });

                document.getElementById('step3DaysSelect').addEventListener('change', (e) => {
                    this.step3Days = parseInt(e.target.value);
                    this.updateStep3Chart();
                });
            }

            updateStep1Chart() {
                console.log(`Actualizando gráfico del Paso 1 - Modelo: ${this.step1Model}, Días: ${this.step1Days}`);
                this.createStep1Chart();
            }

            updateStep2Chart() {
                console.log(`Actualizando gráfico del Paso 2 - Modelo: ${this.step2Model}, Días: ${this.step2Days}`);
                this.createStep2Chart();
            }

            updateStep3Chart() {
                console.log(`Actualizando gráfico del Paso 3 - Modelo: ${this.step3Model}, Días: ${this.step3Days}`);
                this.cleanupChartListeners();
                this.createStep3Chart();
            }

            async loadData() {
                try {
                    console.log('Cargando datos iniciales...');
                    
                    const response = await fetch('/api/historical_data');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    if (data.error) {
                        throw new Error(data.error);
                    }

                    this.data = data;
                    this.updateCharts();

                } catch (error) {
                    console.error('Error cargando datos:', error);
                    this.showError(error.message);
                }
            }

            showError(message) {
                const charts = ['step1Chart', 'step2Chart', 'step3Chart', 'volumeChart', 'indicatorsChart'];
                charts.forEach(chartId => {
                    const element = document.getElementById(chartId);
                    if (element) {
                        element.innerHTML = `
                            <div class="text-center text-danger p-4">
                                <i class="fas fa-exclamation-triangle fa-3x"></i>
                                <p class="mt-3"><strong>Error:</strong> ${message}</p>
                                <button class="btn btn-outline-primary mt-2" onclick="location.reload()">
                                    <i class="fas fa-redo me-2"></i>Reintentar
                                </button>
                            </div>
                        `;
                    }
                });
            }

            updateCharts() {
                console.log('Actualizando gráficos de los 3 pasos...');
                Promise.all([
                    this.createStep1Chart(),
                    this.createStep2Chart(),
                    this.createStep3Chart(),
                    this.createVolumeChart(),
                    this.createIndicatorsChart()
                ]).then(() => {
                    console.log('Todos los gráficos actualizados');
                }).catch(error => {
                    console.error('Error actualizando gráficos:', error);
                });
            }

            async createStep1Chart() {
                try {
                    console.log(`Creando gráfico del Paso 1 - Modelo: ${this.step1Model}, Días: ${this.step1Days}`);
                    
                    // Determinar el modelo correcto para el Paso 1 (regresión)
                    let modelName = this.step1Model;
                    if (this.step1Model === 'logistic_regression') {
                        modelName = 'linear_regression'; // Usar regresión lineal si se selecciona logística
                    }
                    
                    const response = await fetch(`/api/step1_data/${modelName}/${this.step1Days}`);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const stepData = await response.json();
                    
                    const traces = [
                        {
                            x: stepData.dates,
                            y: stepData.actual,
                            type: 'scatter',
                            mode: 'lines',
                            name: 'Precio Real',
                            line: { color: '#2ca02c', width: 2 }
                        },
                        {
                            x: stepData.dates,
                            y: stepData.predictions,
                            type: 'scatter',
                            mode: 'lines',
                            name: `Predicción (${modelName.replace('_', ' ')})`,
                            line: { color: '#ff7f0e', width: 2, dash: 'dash' }
                        }
                    ];

                    // Agregar predicciones futuras si están disponibles
                    if (stepData.future_dates && stepData.future_predictions) {
                        traces.push({
                            x: stepData.future_dates,
                            y: stepData.future_predictions,
                            type: 'scatter',
                            mode: 'lines',
                            name: `Predicción Futura (${this.step1Days} días)`,
                            line: { color: '#d62728', width: 2, dash: 'dot' }
                        });
                    }

                    const layout = {
                        title: `Paso 1: Regresión - ${modelName.replace('_', ' ').toUpperCase()} (${this.step1Days} días)`,
                        xaxis: { 
                            title: 'Fecha',
                            type: 'date'
                        },
                        yaxis: { 
                            title: 'Precio de Cierre',
                            tickformat: '.2f'
                        },
                        hovermode: 'x unified',
                        legend: {
                            orientation: 'h',
                            y: -0.2
                        },
                        margin: { t: 50, b: 100, l: 60, r: 30 },
                        annotations: [{
                            text: `RMSE: ${stepData.metrics.rmse.toFixed(2)} | MAE: ${stepData.metrics.mae.toFixed(2)} | R²: ${stepData.metrics.r2.toFixed(3)}`,
                            xref: 'paper', yref: 'paper',
                            x: 0, y: 1.02, xanchor: 'left', yanchor: 'bottom',
                            showarrow: false,
                            font: { size: 12, color: '#666' }
                        }]
                    };

                    const config = {
                        responsive: true,
                        displayModeBar: true,
                        modeBarButtonsToRemove: ['pan2d', 'lasso2d']
                    };

                    Plotly.newPlot('step1Chart', traces, layout, config);
                    
                } catch (error) {
                    console.error('Error en createStep1Chart:', error);
                    document.getElementById('step1Chart').innerHTML = `
                        <div class="text-center text-danger p-4">
                            <i class="fas fa-chart-line fa-3x"></i>
                            <p class="mt-3">Error cargando gráfico del Paso 1</p>
                        </div>
                    `;
                }
            }

            async createStep2Chart() {
                try {
                    console.log(`Creando gráfico del Paso 2 - Modelo: ${this.step2Model}, Días: ${this.step2Days}`);
                    
                    // Determinar el modelo correcto para el Paso 2 (clasificación)
                    let modelName = this.step2Model;
                    if (this.step2Model === 'linear_regression') {
                        modelName = 'logistic_regression'; // Usar regresión logística si se selecciona lineal
                    }
                    
                    const response = await fetch(`/api/step2_data/${modelName}/${this.step2Days}`);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const stepData = await response.json();
                    
                    // Convertir a valores categóricos para visualización
                    const actualCategories = stepData.actual.map(val => val ? 'Sube' : 'Baja');
                    const predCategories = stepData.predictions.map(val => val ? 'Sube' : 'Baja');
                    
                    // Estilo Diamantes fijo
                    const traces = [
                        {
                            x: stepData.dates,
                            y: stepData.actual.map(val => val ? 1 : -1),
                            type: 'scatter',
                            mode: 'markers',
                            name: 'Dirección Real',
                            marker: {
                                color: stepData.actual.map(val => val ? '#2ca02c' : '#d62728'),
                                size: stepData.probabilities.map(prob => 10 + prob * 20), // Tamaño basado en probabilidad
                                symbol: 'diamond',
                                line: { width: 2, color: '#000' }
                            }
                        },
                        {
                            x: stepData.dates,
                            y: stepData.predictions.map(val => val ? 0.5 : -0.5),
                            type: 'scatter',
                            mode: 'markers',
                            name: 'Predicción del Modelo',
                            marker: {
                                color: stepData.predictions.map(val => val ? '#90EE90' : '#FFB6C1'),
                                size: 12,
                                symbol: 'cross'
                            }
                        },
                        {
                            x: stepData.dates,
                            y: stepData.probabilities,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: 'Probabilidad de Subida',
                            line: { color: '#1f77b4', width: 2 },
                            marker: { size: 4 },
                            yaxis: 'y2'
                        }
                    ];
                    
                    // Agregar predicción futura si está disponible
                    if (stepData.future_prediction) {
                        // Calcular la fecha futura basada en la última fecha de los datos
                        const lastDate = new Date(stepData.dates[stepData.dates.length - 1]);
                        const futureDate = new Date(lastDate);
                        futureDate.setDate(futureDate.getDate() + stepData.future_prediction.prediction_days);
                        
                        traces.push({
                            x: [futureDate.toISOString().split('T')[0]],
                            y: [stepData.future_prediction.prediction ? 1 : -1],
                            type: 'scatter',
                            mode: 'markers+text',
                            name: `Predicción Futura (${stepData.future_prediction.probability.toFixed(3)} prob.)`,
                            text: [stepData.future_prediction.prediction ? '↑' : '↓'],
                            textfont: { 
                                size: 28, 
                                color: stepData.future_prediction.prediction ? '#2ca02c' : '#d62728' 
                            },
                            textposition: 'middle center',
                            marker: {
                                color: stepData.future_prediction.prediction ? '#2ca02c' : '#d62728',
                                size: 20,
                                symbol: 'star'
                            }
                        });
                    }

                    const layout = {
                        title: `Paso 2: Clasificación - ${modelName.replace('_', ' ').toUpperCase()} (${this.step2Days} días)`,
                        xaxis: { 
                            title: 'Fecha',
                            type: 'date'
                        },
                        yaxis: {
                            title: 'Dirección del Precio',
                            range: [-1.5, 1.5],
                            tickvals: [-1, 0, 1],
                            ticktext: ['Baja ↓', 'Neutral', 'Sube ↑'],
                            zeroline: true,
                            zerolinecolor: '#666',
                            zerolinewidth: 2
                        },
                        yaxis2: {
                            title: 'Probabilidad',
                            overlaying: 'y',
                            side: 'right',
                            range: [0, 1]
                        },
                        hovermode: 'x unified',
                        legend: {
                            orientation: 'h',
                            y: -0.2
                        },
                        margin: { t: 50, b: 100, l: 60, r: 60 },
                        annotations: [{
                            text: `Accuracy: ${(stepData.metrics.accuracy * 100).toFixed(1)}% | F1: ${stepData.metrics.f1_score.toFixed(3)} | AUC: ${stepData.metrics.roc_auc.toFixed(3)}${stepData.future_prediction ? ` | Predicción ${stepData.future_prediction.prediction_days}d: ${stepData.future_prediction.prediction ? 'Sube' : 'Baja'} (${(stepData.future_prediction.probability * 100).toFixed(1)}%)` : ''}`,
                            xref: 'paper', yref: 'paper',
                            x: 0, y: 1.02, xanchor: 'left', yanchor: 'bottom',
                            showarrow: false,
                            font: { size: 12, color: '#666' }
                        }]
                    };

                    const config = {
                        responsive: true,
                        displayModeBar: true,
                        modeBarButtonsToRemove: ['pan2d', 'lasso2d']
                    };

                    Plotly.newPlot('step2Chart', traces, layout, config);
                    
                } catch (error) {
                    console.error('Error en createStep2Chart:', error);
                    document.getElementById('step2Chart').innerHTML = `
                        <div class="text-center text-danger p-4">
                            <i class="fas fa-chart-bar fa-3x"></i>
                            <p class="mt-3">Error cargando gráfico del Paso 2</p>
                        </div>
                    `;
                }
            }

            async createStep3Chart() {
                try {
                    console.log(`Creando forecast card del Paso 3 - Modelo: ${this.step3Model}, Días: ${this.step3Days}`);
                    
                    // Determinar el modelo correcto para el Paso 3 (probabilidad)
                    let modelName = this.step3Model;
                    if (this.step3Model === 'linear_regression') {
                        modelName = 'logistic_regression'; // Usar regresión logística si se selecciona lineal
                    }
                    
                    const response = await fetch(`/api/step3_data/${modelName}/${this.step3Days}`);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const stepData = await response.json();
                    
                    // Calcular la fecha futura
                    const lastDate = new Date(stepData.dates[stepData.dates.length - 1]);
                    const futureDate = new Date(lastDate);
                    futureDate.setDate(futureDate.getDate() + this.step3Days);
                    
                    // Obtener las probabilidades para el forecast
                    let upProbability = 0;
                    let downProbability = 0;
                    
                    if (stepData.future_prediction) {
                        upProbability = stepData.future_prediction.probability * 100;
                        downProbability = (1 - stepData.future_prediction.probability) * 100;
                    } else {
                        // Usar la última probabilidad disponible como fallback
                        const lastProb = stepData.probabilities[stepData.probabilities.length - 1];
                        upProbability = lastProb * 100;
                        downProbability = (1 - lastProb) * 100;
                    }
                    
                    // Determinar si es subida o bajada
                    const isUp = upProbability > downProbability;
                    
                    // Crear el HTML del forecast completo con gráfico y predicción
                    const forecastHTML = `
                        <div class="forecast-container">
                            <div class="forecast-chart">
                                <canvas id="step3ProbChart" width="400" height="250"></canvas>
                            </div>
                            
                            <div class="forecast-info">
                                <div class="forecast-header">
                                    <h5 class="forecast-title">Predicción de precio en ${this.step3Days} días</h5>
                                    <small class="forecast-model">${modelName.replace('_', ' ').toUpperCase()}</small>
                                </div>
                                
                                <div class="forecast-probabilities">
                                    <div class="prob-item ${isUp ? 'main' : 'secondary'}">
                                        <div class="prob-arrow up">↑</div>
                                        <div class="prob-text">Subida: ${upProbability.toFixed(1)}%</div>
                                    </div>
                                    <div class="prob-item ${!isUp ? 'main' : 'secondary'}">
                                        <div class="prob-arrow down">↓</div>
                                        <div class="prob-text">Bajada: ${downProbability.toFixed(1)}%</div>
                                    </div>
                                </div>
                                
                                <div class="forecast-date">
                                    Fecha: ${futureDate.toLocaleDateString('es-ES', { 
                                        day: 'numeric', 
                                        month: 'numeric', 
                                        year: 'numeric' 
                                    })}
                                </div>
                                
                                <div class="forecast-metrics">
                                    <small>
                                        Accuracy: ${(stepData.metrics.accuracy * 100).toFixed(1)}% | 
                                        F1: ${stepData.metrics.f1_score.toFixed(3)} | 
                                        AUC: ${stepData.metrics.roc_auc.toFixed(3)}
                                    </small>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    document.getElementById('step3Chart').innerHTML = forecastHTML;
                    
                    // Dibujar el gráfico de probabilidades
                    setTimeout(() => {
                        this.drawProbabilityChart(stepData.dates, stepData.probabilities);
                    }, 100);
                    
                } catch (error) {
                    console.error('Error en createStep3Chart:', error);
                    // Limpiar listeners si hay error
                    this.cleanupChartListeners();
                    document.getElementById('step3Chart').innerHTML = `
                        <div class="text-center text-danger p-4">
                            <i class="fas fa-chart-area fa-3x"></i>
                            <p class="mt-3">Error cargando forecast del Paso 3</p>
                        </div>
                    `;
                }
            }

            cleanupChartListeners() {
                // Limpiar tooltip
                const tooltip = document.getElementById('chart-tooltip');
                if (tooltip) {
                    tooltip.remove();
                }
                
                // Limpiar referencias
                this.chartData = null;
                this.chartZoom = null;
                this.tooltip = null;
            }

            drawProbabilityChart(dates, probabilities) {
                const canvas = document.getElementById('step3ProbChart');
                if (!canvas) return;
                
                // Configurar interactividad
                this.setupCanvasInteractivity(canvas, dates, probabilities);
                
                // Obtener solo los últimos 30 días para el zoom inicial
                const last30Days = Math.min(30, dates.length);
                const startIndex = Math.max(0, dates.length - last30Days);
                
                // Datos filtrados para los últimos 30 días
                const filteredDates = dates.slice(startIndex);
                const filteredProbs = probabilities.slice(startIndex);
                
                // Configurar el zoom inicial
                this.chartZoom = {
                    startIndex: startIndex,
                    endIndex: dates.length - 1,
                    isDragging: false,
                    dragStart: null
                };
                
                this.renderChart(canvas, dates, probabilities, this.chartZoom);
            }

            setupCanvasInteractivity(canvas, dates, probabilities) {
                // Remover listeners anteriores
                canvas.removeEventListener('mousedown', this.canvasMouseDown);
                canvas.removeEventListener('mousemove', this.canvasMouseMove);
                canvas.removeEventListener('mouseup', this.canvasMouseUp);
                canvas.removeEventListener('wheel', this.canvasWheel);
                canvas.removeEventListener('dblclick', this.canvasDoubleClick);
                
                // Bind de contexto para los métodos
                this.canvasMouseDown = this.canvasMouseDown.bind(this);
                this.canvasMouseMove = this.canvasMouseMove.bind(this);
                this.canvasMouseUp = this.canvasMouseUp.bind(this);
                this.canvasWheel = this.canvasWheel.bind(this);
                this.canvasDoubleClick = this.canvasDoubleClick.bind(this);
                
                // Agregar event listeners
                canvas.addEventListener('mousedown', this.canvasMouseDown);
                canvas.addEventListener('mousemove', this.canvasMouseMove);
                canvas.addEventListener('mouseup', this.canvasMouseUp);
                canvas.addEventListener('wheel', this.canvasWheel);
                canvas.addEventListener('dblclick', this.canvasDoubleClick);
                
                // Guardar referencia de datos
                this.chartData = { dates, probabilities };
                
                // Crear tooltip
                this.createTooltip();
            }

            createTooltip() {
                // Remover tooltip anterior si existe
                const existingTooltip = document.getElementById('chart-tooltip');
                if (existingTooltip) {
                    existingTooltip.remove();
                }
                
                // Crear nuevo tooltip
                const tooltip = document.createElement('div');
                tooltip.id = 'chart-tooltip';
                tooltip.style.cssText = `
                    position: absolute;
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 8px 12px;
                    border-radius: 4px;
                    font-size: 12px;
                    pointer-events: none;
                    z-index: 1000;
                    display: none;
                `;
                document.body.appendChild(tooltip);
                this.tooltip = tooltip;
            }

            canvasMouseDown(e) {
                const canvas = e.target;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                
                this.chartZoom.isDragging = true;
                this.chartZoom.dragStart = x;
                canvas.style.cursor = 'grabbing';
            }

            canvasMouseMove(e) {
                const canvas = e.target;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (this.chartZoom.isDragging && this.chartZoom.dragStart !== null) {
                    // Lógica de pan/arrastre
                    const deltaX = x - this.chartZoom.dragStart;
                    const padding = 40;
                    const chartWidth = canvas.width - 2 * padding;
                    const visibleRange = this.chartZoom.endIndex - this.chartZoom.startIndex;
                    const pixelsPerIndex = chartWidth / visibleRange;
                    const indexDelta = Math.floor(deltaX / pixelsPerIndex);
                    
                    if (Math.abs(indexDelta) > 0) {
                        const newStart = Math.max(0, this.chartZoom.startIndex - indexDelta);
                        const newEnd = Math.min(this.chartData.dates.length - 1, this.chartZoom.endIndex - indexDelta);
                        
                        if (newEnd - newStart === visibleRange) {
                            this.chartZoom.startIndex = newStart;
                            this.chartZoom.endIndex = newEnd;
                            this.chartZoom.dragStart = x;
                            this.renderChart(canvas, this.chartData.dates, this.chartData.probabilities, this.chartZoom);
                        }
                    }
                } else {
                    // Mostrar tooltip
                    this.showTooltip(e, x, y);
                }
            }

            canvasMouseUp(e) {
                const canvas = e.target;
                this.chartZoom.isDragging = false;
                this.chartZoom.dragStart = null;
                canvas.style.cursor = 'default';
            }

            canvasWheel(e) {
                e.preventDefault();
                const canvas = e.target;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                
                // Zoom con rueda del mouse
                const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
                const padding = 40;
                const chartWidth = canvas.width - 2 * padding;
                const currentRange = this.chartZoom.endIndex - this.chartZoom.startIndex;
                const newRange = Math.max(5, Math.min(this.chartData.dates.length, Math.floor(currentRange * zoomFactor)));
                
                // Calcular punto de zoom basado en posición del mouse
                const mousePos = (x - padding) / chartWidth;
                const centerIndex = this.chartZoom.startIndex + mousePos * currentRange;
                
                const newStart = Math.max(0, Math.floor(centerIndex - newRange / 2));
                const newEnd = Math.min(this.chartData.dates.length - 1, newStart + newRange);
                
                this.chartZoom.startIndex = newStart;
                this.chartZoom.endIndex = newEnd;
                
                this.renderChart(canvas, this.chartData.dates, this.chartData.probabilities, this.chartZoom);
            }

            canvasDoubleClick(e) {
                // Reset zoom a últimos 30 días
                const last30Days = Math.min(30, this.chartData.dates.length);
                this.chartZoom.startIndex = Math.max(0, this.chartData.dates.length - last30Days);
                this.chartZoom.endIndex = this.chartData.dates.length - 1;
                
                this.renderChart(e.target, this.chartData.dates, this.chartData.probabilities, this.chartZoom);
            }

            showTooltip(e, x, y) {
                const canvas = e.target;
                const padding = 40;
                const chartWidth = canvas.width - 2 * padding;
                const chartHeight = canvas.height - 2 * padding;
                
                if (x >= padding && x <= canvas.width - padding && y >= padding && y <= canvas.height - padding) {
                    const relativeX = (x - padding) / chartWidth;
                    const visibleRange = this.chartZoom.endIndex - this.chartZoom.startIndex;
                    const dataIndex = Math.floor(this.chartZoom.startIndex + relativeX * visibleRange);
                    
                    if (dataIndex >= 0 && dataIndex < this.chartData.dates.length) {
                        const date = new Date(this.chartData.dates[dataIndex]).toLocaleDateString('es-ES');
                        const prob = (this.chartData.probabilities[dataIndex] * 100).toFixed(1);
                        
                        this.tooltip.innerHTML = `
                            <strong>Fecha:</strong> ${date}<br>
                            <strong>Probabilidad:</strong> ${prob}%
                        `;
                        
                        this.tooltip.style.display = 'block';
                        this.tooltip.style.left = (e.clientX + 10) + 'px';
                        this.tooltip.style.top = (e.clientY - 10) + 'px';
                        return;
                    }
                }
                
                this.tooltip.style.display = 'none';
            }

            renderChart(canvas, dates, probabilities, zoom) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Limpiar canvas
                ctx.clearRect(0, 0, width, height);
                
                // Configuración del gráfico
                const padding = 40;
                const chartWidth = width - 2 * padding;
                const chartHeight = height - 2 * padding;
                
                // Datos filtrados según el zoom
                const visibleDates = dates.slice(zoom.startIndex, zoom.endIndex + 1);
                const visibleProbs = probabilities.slice(zoom.startIndex, zoom.endIndex + 1);
                
                // Dibujar ejes
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                
                // Eje Y (probabilidad)
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, height - padding);
                ctx.stroke();
                
                // Eje X (tiempo)
                ctx.beginPath();
                ctx.moveTo(padding, height - padding);
                ctx.lineTo(width - padding, height - padding);
                ctx.stroke();
                
                // Líneas de grid horizontales
                for (let i = 0; i <= 10; i++) {
                    const y = padding + (i / 10) * chartHeight;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(width - padding, y);
                    ctx.strokeStyle = i === 5 ? '#ccc' : '#f0f0f0';
                    ctx.stroke();
                }
                
                // Etiquetas del eje Y
                ctx.fillStyle = '#666';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';
                for (let i = 0; i <= 10; i++) {
                    const y = height - padding - (i / 10) * chartHeight;
                    ctx.fillText(`${i * 10}%`, padding - 5, y + 4);
                }
                
                // Etiquetas del eje X (fechas)
                ctx.textAlign = 'center';
                const maxLabels = 5;
                const labelStep = Math.max(1, Math.floor(visibleDates.length / maxLabels));
                for (let i = 0; i < visibleDates.length; i += labelStep) {
                    const x = padding + (i / (visibleDates.length - 1)) * chartWidth;
                    const date = new Date(visibleDates[i]).toLocaleDateString('es-ES', { 
                        day: 'numeric', 
                        month: 'short' 
                    });
                    ctx.fillText(date, x, height - padding + 20);
                }
                
                // Dibujar línea de probabilidad
                if (visibleProbs.length > 1) {
                    ctx.beginPath();
                    ctx.strokeStyle = '#3498db';
                    ctx.lineWidth = 2;
                    
                    for (let i = 0; i < visibleProbs.length; i++) {
                        const x = padding + (i / (visibleProbs.length - 1)) * chartWidth;
                        const y = height - padding - (visibleProbs[i] * chartHeight);
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                    
                    // Dibujar puntos
                    ctx.fillStyle = '#3498db';
                    for (let i = 0; i < visibleProbs.length; i++) {
                        const x = padding + (i / (visibleProbs.length - 1)) * chartWidth;
                        const y = height - padding - (visibleProbs[i] * chartHeight);
                        
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
                
                // Línea de 50%
                ctx.beginPath();
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                const middleY = height - padding - (0.5 * chartHeight);
                ctx.moveTo(padding, middleY);
                ctx.lineTo(width - padding, middleY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Etiqueta de 50%
                ctx.fillStyle = '#e74c3c';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('50%', width - padding + 5, middleY + 4);
                
                // Título del gráfico
                ctx.fillStyle = '#333';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Evolución de Probabilidad de Incremento ', width / 2, 20);
                
                // Instrucciones
                ctx.fillStyle = '#999';
                ctx.font = '10px Arial';
                ctx.fillText('Rueda: Zoom | Arrastrar: Pan | Doble clic: Reset', width / 2, height - 5);
            }

            async createVolumeChart() {
                try {
                    console.log('Cargando datos para gráfico de volumen...');
                    
                    if (!this.data || !this.data.volume) {
                        console.log('No hay datos de volumen disponibles');
                        document.getElementById('volumeChart').innerHTML = `
                            <div class="text-center text-muted p-3">
                                <p>No hay datos de volumen disponibles</p>
                            </div>
                        `;
                        return;
                    }

                    const trace = {
                        x: this.data.dates,
                        y: this.data.volume,
                        type: 'bar',
                        name: 'Volumen',
                        marker: { color: '#9467bd' }
                    };

                    const layout = {
                        title: 'Volumen de Transacciones',
                        xaxis: { title: 'Fecha', type: 'date' },
                        yaxis: { title: 'Volumen' },
                        margin: { t: 50, b: 60, l: 60, r: 30 }
                    };

                    await Plotly.newPlot('volumeChart', [trace], layout, { responsive: true });
                    console.log('Gráfico de volumen creado exitosamente');

                } catch (error) {
                    console.error('Error creando gráfico de volumen:', error);
                    document.getElementById('volumeChart').innerHTML = `
                        <div class="text-center text-danger p-3">
                            <i class="fas fa-chart-bar fa-2x"></i>
                            <p class="mt-2">Error cargando volumen</p>
                        </div>
                    `;
                }
            }

            async createIndicatorsChart() {
                try {
                    console.log('Cargando datos para indicadores técnicos...');
                    
                    if (!this.data || !this.data.rsi) {
                        console.log('No hay datos de indicadores disponibles');
                        document.getElementById('indicatorsChart').innerHTML = `
                            <div class="text-center text-muted p-3">
                                <p>No hay datos de indicadores disponibles</p>
                            </div>
                        `;
                        return;
                    }

                    const traces = [
                        {
                            x: this.data.dates,
                            y: this.data.rsi,
                            type: 'scatter',
                            mode: 'lines',
                            name: 'RSI',
                            line: { color: '#ff7f0e' },
                            yaxis: 'y'
                        },
                        {
                            x: this.data.dates,
                            y: this.data.macd,
                            type: 'scatter',
                            mode: 'lines',
                            name: 'MACD',
                            line: { color: '#2ca02c' },
                            yaxis: 'y2'
                        }
                    ];

                    const layout = {
                        title: 'Indicadores Técnicos',
                        xaxis: { title: 'Fecha', type: 'date' },
                        yaxis: { 
                            title: 'RSI', 
                            side: 'left',
                            range: [0, 100]
                        },
                        yaxis2: {
                            title: 'MACD',
                            side: 'right',
                            overlaying: 'y'
                        },
                        margin: { t: 50, b: 60, l: 60, r: 60 }
                    };

                    await Plotly.newPlot('indicatorsChart', traces, layout, { responsive: true });
                    console.log('Gráfico de indicadores creado exitosamente');

                } catch (error) {
                    console.error('Error creando gráfico de indicadores:', error);
                    document.getElementById('indicatorsChart').innerHTML = `
                        <div class="text-center text-danger p-3">
                            <i class="fas fa-chart-line fa-2x"></i>
                            <p class="mt-2">Error cargando indicadores</p>
                        </div>
                    `;
                }
            }

        }

        // Inicializar dashboard cuando se carga la página
        document.addEventListener('DOMContentLoaded', () => {
            new CryptoDashboard();
        });
    </script>
</body>
</html>
